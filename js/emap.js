// Generated by CoffeeScript 1.10.0
(function() {
  var Dict, EventMap,
    slice = [].slice;

  if (require) {
    Dict = require('jsdictionary');
  } else {
    Dict = this.JSDictionary;
  }

  EventMap = (function() {

    /*
        00000000  000   000  00000000  000   000  000000000  00     00   0000000   00000000
        000       000   000  000       0000  000     000     000   000  000   000  000   000
        0000000    000 000   0000000   000 0 000     000     000000000  000000000  00000000
        000          000     000       000  0000     000     000 0 000  000   000  000
        00000000      0      00000000  000   000     000     000   000  000   000  000
     */
    function EventMap() {
      this.dispatcherMap = new Dict();
    }


    /*
        00     00   0000000   00000000
        000   000  000   000  000   000
        000000000  000000000  00000000
        000 0 000  000   000  000
        000   000  000   000  000
     */

    EventMap.prototype.map = function(dispatcher, type, handler, owner, useCapture) {
      var callback, info, j, len, listenerMap, listeners, ref, ref1;
      if (useCapture == null) {
        useCapture = false;
      }
      listenerMap = (ref = this.dispatcherMap.get(dispatcher)) != null ? ref : this.dispatcherMap.map(dispatcher, {});
      listeners = (ref1 = listenerMap[type]) != null ? ref1 : listenerMap[type] = [];
      for (j = 0, len = listeners.length; j < len; j++) {
        info = listeners[j];
        if (info.h === handler && info.o === owner && info.u === useCapture) {
          return null;
        }
      }
      if (dispatcher.addEventListener) {
        if (owner) {
          callback = function() {
            var args;
            args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
            handler.apply(owner, args);
            return null;
          };
          dispatcher.addEventListener(type, callback, useCapture);
        } else {
          dispatcher.addEventListener(type, handler, useCapture);
        }
      } else if (dispatcher.on) {
        if (owner) {
          callback = function() {
            var args;
            args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
            handler.apply(owner, args);
            return null;
          };
          dispatcher.on(type, callback, useCapture);
        } else {
          dispatcher.on(type, handler, useCapture);
        }
      } else if (dispatcher.add) {
        dispatcher.add(type, handler, owner);
      }
      listeners.push({
        d: dispatcher,
        o: owner,
        h: handler,
        u: useCapture,
        c: callback
      });
      return null;
    };


    /*
        000   000  000   000  00     00   0000000   00000000
        000   000  0000  000  000   000  000   000  000   000
        000   000  000 0 000  000000000  000000000  00000000
        000   000  000  0000  000 0 000  000   000  000
         0000000   000   000  000   000  000   000  000
     */

    EventMap.prototype.unmap = function(dispatcher, type, handler, owner, useCapture) {
      var i, info, listenerMap, listeners;
      if (useCapture == null) {
        useCapture = false;
      }
      listenerMap = this.dispatcherMap.get(dispatcher);
      if (!listenerMap) {
        return null;
      }
      listeners = listenerMap[type];
      if (!listeners) {
        return null;
      }
      i = listeners.length;
      while (--i >= 0) {
        info = listeners[i];
        if (info.h === handler && info.o === owner && info.u === useCapture) {
          listeners.splice(i, 1);
          if (dispatcher.removeEventListener) {
            if (owner) {
              dispatcher.removeEventListener(type, info.c, useCapture);
            } else {
              dispatcher.removeEventListener(type, handler, useCapture);
            }
          } else if (dispatcher.off) {
            if (owner) {
              dispatcher.off(type, info.c, useCapture);
            } else {
              dispatcher.off(type, handler, useCapture);
            }
          } else if (dispatcher.remove) {
            dispatcher.remove(type, handler, owner);
          }
        }
      }
      if (!listeners.length) {
        delete listenerMap[type];
      }
      if (!Dict.hasKeys(listenerMap)) {
        this.dispatcherMap.unmap(dispatcher);
      }
      return null;
    };


    /*
         0000000   000      000
        000   000  000      000
        000000000  000      000
        000   000  000      000
        000   000  0000000  0000000
     */

    EventMap.prototype.all = function() {
      this.dispatcherMap.forEach((function(_this) {
        return function(dispatcher, listenerMap) {
          var info, listeners, type;
          for (type in listenerMap) {
            listeners = listenerMap[type];
            while (info = listeners.shift()) {
              if (dispatcher.removeEventListener) {
                if (info.o) {
                  dispatcher.removeEventListener(type, info.c, info.u);
                } else {
                  dispatcher.removeEventListener(type, info.h, info.u);
                }
              } else if (dispatcher.off) {
                if (info.o) {
                  dispatcher.off(type, info.c, info.u);
                } else {
                  dispatcher.off(type, info.h, info.u);
                }
              } else if (dispatcher.remove) {
                dispatcher.remove(type, info.h, info.o);
              }
            }
          }
          return _this.dispatcherMap.unmap(dispatcher);
        };
      })(this));
      return null;
    };

    return EventMap;

  })();


  /*
      00000000  000   000  00000000    0000000   00000000   000000000   0000000
      000        000 000   000   000  000   000  000   000     000     000
      0000000     00000    00000000   000   000  0000000       000     0000000
      000        000 000   000        000   000  000   000     000          000
      00000000  000   000  000         0000000   000   000     000     0000000
   */

  if (module) {

    /* node export */
    module.exports = EventMap;
  } else {

    /* browser export */
    this.EventMap = EventMap;
  }

}).call(this);

//# sourceMappingURL=emap.js.map
